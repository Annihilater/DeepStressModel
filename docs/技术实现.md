# DeepStressModel 技术实现文档

## 核心技术实现细节

### 1. GUI模块实现

#### 1.1 主窗口设计
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("DeepStressModel")
        self.resize(1200, 800)
        
        # 创建标签页
        self.tab_widget = QTabWidget()
        self.setCentralWidget(self.tab_widget)
        
        # 添加三个主要标签页
        self.test_tab = TestTab()
        self.settings_tab = SettingsTab()
        self.results_tab = ResultsTab()
        
        self.tab_widget.addTab(self.test_tab, "测试")
        self.tab_widget.addTab(self.settings_tab, "设置")
        self.tab_widget.addTab(self.results_tab, "记录")
```

#### 1.2 测试界面布局
```python
class TestTab(QWidget):
    def __init__(self):
        super().__init__()
        
        # 左侧控制面板
        self.control_panel = QWidget()
        self.model_selector = QComboBox()
        self.dataset_selector = DatasetSelector()  # 自定义多选控件
        self.concurrency_spinner = QSpinBox()
        self.start_button = QPushButton("开始测试")
        
        # 右侧结果显示区
        self.result_panel = QWidget()
        self.gpu_monitor = GPUMonitorWidget()  # 自定义GPU监控图表
        self.test_progress = TestProgressWidget()  # 自定义进度显示
        self.stats_display = StatsDisplayWidget()  # 自定义统计数据显示
```

### 2. 测试引擎实现

#### 2.1 异步测试管理器
```python
class TestManager:
    def __init__(self):
        self.api_client = APIClient()
        self.running_tasks = []
        self.results_queue = asyncio.Queue()
        
    async def start_test(self, config, datasets, concurrency):
        self.test_tasks = []
        for _ in range(concurrency):
            task = asyncio.create_task(self._worker())
            self.test_tasks.append(task)
            
    async def _worker(self):
        while True:
            prompt = await self.prompt_queue.get()
            try:
                result = await self.api_client.generate(prompt)
                await self.results_queue.put(result)
            except Exception as e:
                await self.results_queue.put({"error": str(e)})
```

#### 2.2 OpenAI API客户端
```python
class APIClient:
    def __init__(self, api_url, api_key):
        self.api_url = api_url
        self.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }
        self.session = aiohttp.ClientSession()
        
    async def generate(self, prompt):
        start_time = time.time()
        async with self.session.post(
            self.api_url,
            json={"prompt": prompt},
            headers=self.headers
        ) as response:
            result = await response.json()
            duration = time.time() - start_time
            return {
                "response": result,
                "duration": duration,
                "tokens": len(result["choices"][0]["text"].split())
            }
```

### 3. GPU监控实现

#### 3.1 本地GPU监控
```python
class LocalGPUMonitor:
    def __init__(self):
        pynvml.nvmlInit()
        self.handle = pynvml.nvmlDeviceGetHandleByIndex(0)
        
    def get_stats(self):
        memory = pynvml.nvmlDeviceGetMemoryInfo(self.handle)
        utilization = pynvml.nvmlDeviceGetUtilizationRates(self.handle)
        temperature = pynvml.nvmlDeviceGetTemperature(
            self.handle, pynvml.NVML_TEMPERATURE_GPU
        )
        
        return {
            "memory_used": memory.used / 1024**2,
            "memory_total": memory.total / 1024**2,
            "gpu_util": utilization.gpu,
            "temperature": temperature
        }
```

#### 3.2 远程GPU监控
```python
class RemoteGPUMonitor:
    def __init__(self, host, username, password):
        self.ssh = paramiko.SSHClient()
        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        self.ssh.connect(host, username=username, password=password)
        
    def get_stats(self):
        stdin, stdout, stderr = self.ssh.exec_command('nvidia-smi --query-gpu=memory.used,memory.total,utilization.gpu,temperature.gpu --format=csv,noheader,nounits')
        output = stdout.read().decode().strip()
        memory_used, memory_total, gpu_util, temp = map(float, output.split(','))
        
        return {
            "memory_used": memory_used,
            "memory_total": memory_total,
            "gpu_util": gpu_util,
            "temperature": temp
        }
```

### 4. 数据管理实现

#### 4.1 数据库管理器
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

class DatabaseManager:
    def __init__(self):
        self.engine = create_engine('sqlite:///data/deepstress.db')
        Session = sessionmaker(bind=self.engine)
        self.session = Session()
        
    def init_db(self):
        Base.metadata.create_all(self.engine)
```

#### 4.2 模型配置管理
```python
class ModelConfigManager:
    def __init__(self, db_manager):
        self.db = db_manager
        
    def add_model(self, name, api_url, api_key, model_name):
        model = ModelConfig(
            name=name,
            api_url=api_url,
            api_key=api_key,
            model_name=model_name
        )
        self.db.session.add(model)
        self.db.session.commit()
```

### 5. 报告模块实现

#### 5.1 数据可视化
```python
class TestResultVisualizer:
    def __init__(self):
        self.figure = plt.figure(figsize=(10, 6))
        
    def plot_response_times(self, test_results):
        plt.clf()
        times = [result.duration for result in test_results]
        plt.hist(times, bins=30)
        plt.xlabel('响应时间 (秒)')
        plt.ylabel('频率')
        plt.title('响应时间分布')
        
    def plot_generation_speed(self, test_results):
        plt.clf()
        speeds = [result.generation_speed for result in test_results]
        plt.plot(speeds)
        plt.xlabel('请求序号')
        plt.ylabel('生成速度 (字符/秒)')
        plt.title('生成速度变化')
```

## 关键类和接口定义

### 1. 数据模型
```python
class ModelConfig(Base):
    __tablename__ = 'model_configs'
    
    id = Column(Integer, primary_key=True)
    name = Column(String)
    api_url = Column(String)
    api_key = Column(String)
    model_name = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow)

class TestResult(Base):
    __tablename__ = 'test_results'
    
    id = Column(Integer, primary_key=True)
    model_config_id = Column(Integer, ForeignKey('model_configs.id'))
    start_time = Column(DateTime)
    end_time = Column(DateTime)
    concurrency = Column(Integer)
    avg_response_time = Column(Float)
    avg_generation_speed = Column(Float)
    total_generation_speed = Column(Float)
    successful_requests = Column(Integer)
    failed_requests = Column(Integer)
```

### 2. 事件信号
```python
class TestSignals(QObject):
    test_started = Signal()
    test_finished = Signal()
    result_received = Signal(dict)
    error_occurred = Signal(str)
    gpu_stats_updated = Signal(dict)
```

## 实现注意事项

1. **异步处理**
   - 使用 `asyncio` 处理并发请求
   - GUI事件循环与异步任务的整合
   - 避免阻塞主线程

2. **内存管理**
   - 及时清理不需要的测试结果
   - 大量测试数据的分批处理
   - 图表数据的定期更新和清理

3. **错误处理**
   - API请求超时和重试机制
   - GPU监控连接失败的容错处理
   - 数据库操作的事务管理

4. **性能优化**
   - 使用连接池管理数据库连接
   - 批量插入测试结果
   - 图表更新的节流控制

5. **安全性**
   - API密钥的加密存储
   - SSH凭据的安全管理
   - 输入验证和清理

## 开发建议

1. **模块化开发顺序**
   - 先实现基础GUI框架
   - 完成本地GPU监控
   - 实现基本的API测试功能
   - 逐步添加数据管理和报告功能

2. **测试策略**
   - 单元测试覆盖核心功能
   - GUI自动化测试
   - 压力测试和性能基准测试

3. **代码质量保证**
   - 使用类型注解
   - 编写详细的文档字符串
   - 遵循PEP 8编码规范
   - 定期代码审查 